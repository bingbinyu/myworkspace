Übungsblatt 07, WS 2016/17

Aufgabe 1 (3 Punkte)

  a) 
     0.5 P: Zugriff auf storage und count in erzeugen()
     0.5 P: Zugriff auf count (2x) und storage in verbrauchen()

  b) (siehe auch ml/einseitig.pseudo)

     1 P: Schützen des kritischen Abschnitts in erzeugen()
     1 P: Schützen des kritischen Abschnitts in verbrauchen()
     1 P: minimale kritische Abschnitte gewählt (z. B. Abfrage von
          produkt und sell(produkt) in verbrauchen nicht enthalten)

Aufgabe 2 (3 Punkte)

  2 P.:

  Hier ist weniger das Ergebnis relevant als eine vernünftige Analyse
  anhand möglicher verzahnter Ausführung.
  Zentral für das Funktionieren ist, dass wenn ein Thread zu dem Block
  mit LOAD x, BEQZ lock gelangt, "sein" Flag 0 ist, während des anderen
  Flag 1 ist.

  ObdA sei A == 0 und Thread A bei LOAD B angelangt:

  Fall 1: B ist 0 ->   anschließendes BEQZ führt zum erneuten Versuch.
  Fall 2: B ist 1 ->   es muss sichergestellt sein, dass Thread B
                       nicht zu LOAD A, BEQZ lock gelangt ist.
                       Thread B könnte dorthin gelangt sein, wenn
                       B == 0 und A == 1 war. Das könnte passieren
                       wenn Thread B den Wert aus A liest, bevor Thread
                       A die Zeile STORE A erreicht. B ist zu dem Zeitpunkt
                       schon auf 0 gesetzt worden, weil B den Wert aus A erst
                       nach dem Schreiben des eigenen Werts (0)  einliest.
                       Thread A kommt dann aber nicht über BEQZ hinaus, weil
                       B == 0 sein muss. (Widerspruch)

   1 P.: Eine Schwäche des Algorithmus ist, dass ein symmetrisches
         Scheduling zu einer Verklemmung führen kann, während der kein
         Thread in den kritischen Abschnitt gelangt. Diese löst sich
         aber von selbst auf, sobald sich die Schedulingreihenfolge
         ändert.

